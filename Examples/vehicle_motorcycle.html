<!DOCTYPE html>
<html lang="en">

<head>
	<title>JoltPhysics.js demo</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<div id="container">Loading...</div>
	<div id="info">
		JoltPhysics.js motorcycle controller demo<br />
		WASD to move. Z to hand brake
	</div>

	<script src="js/three/three.min.js"></script>
	<script src="js/three/OrbitControls.js"></script>
	<script src="js/three/WebGL.js"></script>
	<script src="js/three/stats.min.js"></script>
	<script src="js/example.js"></script>

	<script type="module">
		// In case you haven't built the library yourself, replace URL with: https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js
		import initJolt from './js/jolt-physics.wasm-compat.js';

		const position = [0, 2, 0];

		const back_wheel_radius = 0.31;
		const back_wheel_width = 0.05;
		const back_wheel_pos_z = -0.75;
		const back_suspension_min_length = 0.3;
		const back_suspension_max_length = 0.5;
		const back_suspension_freq = 2.0;
		const back_brake_torque = 250.0;

		const front_wheel_radius = 0.31;
		const front_wheel_width = 0.05;
		const front_wheel_pos_z = 0.75;
		const front_suspension_min_length = 0.3;
		const front_suspension_max_length = 0.5;
		const front_suspension_freq = 1.5;
		const front_brake_torque = 500.0;

		const half_vehicle_length = 0.4;
		const half_vehicle_width = 0.2;
		const half_vehicle_height = 0.3;

		const max_steering_angle = DegreesToRadians(30);
		const steerSpeed = 4.0;

		// Angle of the front suspension
		const caster_angle = DegreesToRadians(30);

		const vehicle_mass = 240.0;

		const max_pitch_roll_angle = DegreesToRadians(60);

		let previousForward = 1.0;
		let currentRight = 0.0;

		initJolt().then(function (Jolt) {
			// Initialize this example
			window.Jolt = Jolt;
			container = document.getElementById('container');
			container.innerHTML = "";

			initGraphics();
			initPhysics();
			createVehicleTrack();

			// Create material for wheel
			const texLoader = new THREE.TextureLoader();
			const texture = texLoader.load('data:image/gif;base64,R0lGODdhAgACAIABAAAAAP///ywAAAAAAgACAAACA0QCBQA7');
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.offset.set(0, 0);
			texture.repeat.set(3, 3);
			texture.magFilter = THREE.NearestFilter;
			let wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
			wheelMaterial.map = texture;

			const createThreeWheel = (constraint, wheelIndex, body) => {
				// Create wheel mesh
				const joltWheel = constraint.GetWheel(wheelIndex);
				const wheelSetting = joltWheel.GetSettings();
				const wheel = new THREE.Mesh(new THREE.CylinderGeometry(wheelSetting.mRadius, wheelSetting.mRadius, wheelSetting.mWidth, 20, 1), wheelMaterial);
				body.add(wheel);

				// Function to update the orientation of the wheel
				wheel.updateLocalTransform = () => {
					let transform = constraint.GetWheelLocalTransform(wheelIndex, new Jolt.Vec3(0, 1, 0), new Jolt.Vec3(1, 0, 0));
					wheel.position.copy(wrapVec3(transform.GetTranslation()));
					wheel.quaternion.copy(wrapQuat(transform.GetRotation().GetQuaternion()));
				};
				wheel.updateLocalTransform();

				return wheel;
			}

			// Create motorcycle body
			const motorcycle_shape_settings = new Jolt.OffsetCenterOfMassShapeSettings(new Jolt.Vec3(0, -half_vehicle_height, 0),
				new Jolt.BoxShapeSettings(new Jolt.Vec3(half_vehicle_width, half_vehicle_height, half_vehicle_length)));
			const motorcycle_shape = motorcycle_shape_settings.Create().Get();
			const motorcycle_body_settings = new Jolt.BodyCreationSettings(motorcycle_shape, new Jolt.Vec3(...position),
				Jolt.Quat.prototype.sRotation(new Jolt.Vec3(0, 1, 0), Math.PI),
				Jolt.EMotionType_Dynamic, LAYER_MOVING)
			motorcycle_body_settings.mOverrideMassProperties = Jolt.EOverrideMassProperties_CalculateInertia;
			motorcycle_body_settings.mMassPropertiesOverride.mMass = vehicle_mass;
			const motorcycle_body = bodyInterface.CreateBody(motorcycle_body_settings);
			bodyInterface.AddBody(motorcycle_body.GetID(), Jolt.EActivation_Activate);
			addToScene(motorcycle_body, 0xFF0000);

			const vehicle = new Jolt.VehicleConstraintSettings();
			vehicle.mDrawConstraintSize = 0.1;
			vehicle.mMaxPitchRollAngle = max_pitch_roll_angle;

			const motorcycle = dynamicObjects[dynamicObjects.length - 1];

			vehicle.mWheels.clear();
			{
				const front = new Jolt.WheelSettingsWV();
				front.mPosition = new Jolt.Vec3(0.0, -0.9 * half_vehicle_height, front_wheel_pos_z);
				front.mMaxSteerAngle = max_steering_angle;
				front.mSuspensionDirection = new Jolt.Vec3(0, -1, Math.tan(caster_angle)).Normalized();
				front.mSteeringAxis = new Jolt.Vec3(0, 1, -Math.tan(caster_angle)).Normalized();
				front.mRadius = front_wheel_radius;
				front.mWidth = front_wheel_width;
				front.mSuspensionMinLength = front_suspension_min_length;
				front.mSuspensionMaxLength = front_suspension_max_length;
				front.mSuspensionSpring.mFrequency = front_suspension_freq;
				front.mMaxBrakeTorque = front_brake_torque;

				vehicle.mWheels.push_back(front);

				const back = new Jolt.WheelSettingsWV();
				back.mPosition = new Jolt.Vec3(0.0, -0.9 * half_vehicle_height, back_wheel_pos_z);
				back.mMaxSteerAngle = 0.0;
				back.mRadius = back_wheel_radius;
				back.mWidth = back_wheel_width;
				back.mSuspensionMinLength = back_suspension_min_length;
				back.mSuspensionMaxLength = back_suspension_max_length;
				back.mSuspensionSpring.mFrequency = back_suspension_freq;
				back.mMaxBrakeTorque = back_brake_torque;

				vehicle.mWheels.push_back(back);
			}

			const controller_settings = new Jolt.MotorcycleControllerSettings();
			controller_settings.mEngine.mMaxTorque = 150.0;
			controller_settings.mEngine.mMinRPM = 1000.0;
			controller_settings.mEngine.mMaxRPM = 10000.0;
			controller_settings.mTransmission.mShiftDownRPM = 2000.0;
			controller_settings.mTransmission.mShiftUpRPM = 8000.0;
			controller_settings.mTransmission.mClutchStrength = 2.0;
			vehicle.mController = controller_settings;

			controller_settings.mDifferentials.clear();
			const differential = new Jolt.VehicleDifferentialSettings();
			differential.mLeftWheel = -1;
			differential.mRightWheel = 1;
			differential.mDifferentialRatio = 1.93 * 40.0 / 16.0;;
			controller_settings.mDifferentials.push_back(differential);

			const constraint = new Jolt.VehicleConstraint(motorcycle_body, vehicle);

			const tester = new Jolt.VehicleCollisionTesterCastCylinder(LAYER_MOVING, 1);
			constraint.SetVehicleCollisionTester(tester);

			physicsSystem.AddConstraint(constraint);
			const controller = Jolt.castObject(constraint.GetController(), Jolt.MotorcycleController);

			const modelWheels = [];
			for (let i = 0; i < vehicle.mWheels.size(); i++) {
				modelWheels.push(createThreeWheel(constraint, i, motorcycle));
			}

			const input = {
				direction: new THREE.Vector3(),
				hand_brake: false
			};

			const prePhysicsUpdate = (deltaTime) => {
				let forward = 0.0, right = 0.0, brake = 0.0, hand_brake = 0.0;

				if (input.direction.z != 0) {
					forward = input.direction.z;
				}

				if (previousForward * forward < 0.0) {
					const rotation = wrapQuat(motorcycle_body.GetRotation().Conjugated());
					const linearV = wrapVec3(motorcycle_body.GetLinearVelocity());
					const velocity = linearV.applyQuaternion(rotation).z;
					if ((forward > 0.0 && velocity < -0.1) || (forward < 0.0 && velocity > 0.1)) {
						// Brake while we've not stopped yet
						forward = 0.0;
						brake = 1.0;
					}
					else {
						// When we've come to a stop, accept the new direction
						previousForward = forward;
					}
				}

				if (input.hand_brake) {
					forward = 0.0;
					hand_brake = 1.0;
				}

				if (input.direction.x > currentRight)
					currentRight = Math.min(currentRight + steerSpeed * deltaTime, input.direction.x);
				else if (input.direction.x < currentRight)
					currentRight = Math.max(currentRight - steerSpeed * deltaTime, input.direction.x);
				right = currentRight;

				controller.SetDriverInput(forward, right, brake, hand_brake);
				if (right != 0.0 || forward != 0.0 || brake != 0.0 || hand_brake != 0.0)
					bodyInterface.ActivateBody(motorcycle_body.GetID());
			}

			controls.target = motorcycle.position;
			let oldPos = wrapVec3(motorcycle_body.GetPosition());
			onExampleUpdate = (time, deltaTime) => {
				prePhysicsUpdate(deltaTime);

				const pos = wrapVec3(motorcycle_body.GetPosition());
				camera.position.add(pos.clone().sub(oldPos));
				oldPos = pos;

				modelWheels.forEach(wheel => wheel.updateLocalTransform());
			}

			document.addEventListener("keydown", onDocumentKeyDown, false);
			document.addEventListener("keyup", onDocumentKeyUp, false);
			function onDocumentKeyDown(event) {
				var keyCode = event.key;
				if (keyCode == 'w') {
					input.direction.z = 1;
				} else if (keyCode == 's') {
					input.direction.z = -1;
				} else if (keyCode == 'a') {
					input.direction.x = -1;
				} else if (keyCode == 'd') {
					input.direction.x = 1;
				} else if (keyCode == 'z') {
					input.hand_brake = true;
				}
			};
			function onDocumentKeyUp(event) {
				var keyCode = event.key;
				if (keyCode == 'w') {
					input.direction.z = 0;
				} else if (keyCode == 's') {
					input.direction.z = 0;
				} else if (keyCode == 'a') {
					input.direction.x = 0;
				} else if (keyCode == 'd') {
					input.direction.x = 0;
				} else if (keyCode == 'z') {
					input.hand_brake = false;
				}
			};

			physicsSystem.AddStepListener(new Jolt.VehicleConstraintStepListener(constraint));
			renderExample();
		});

	</script>
</body>

</html>