<!DOCTYPE html>
<html lang="en">
	<head>
		<title>JoltPhysics.js demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
		<div id="container">Loading...</div>
		<div id="info">JoltPhysics.js ray cast demo</div>

		<script src="js/three/three.min.js"></script>
		<script src="js/three/OrbitControls.js"></script>
		<script src="js/three/WebGL.js"></script>
		<script src="js/three/stats.min.js"></script>
		<script src="js/example.js"></script>

		<script type="module">
			// In case you haven't built the library yourself, replace URL with: https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js
			import initJolt from './js/jolt-physics.wasm-compat.js';

			initJolt().then(function (Jolt) {
				// Initialize this example
				initExample(Jolt, null);

				// Create a basic floor
				createFloor();

				// Create some boxes
				createBox(new Jolt.Vec3(0, 1, 0), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(1, 1, 1), Jolt.EMotionType_Static, Jolt.NON_MOVING, 0x00ff00);
				createBox(new Jolt.Vec3(0, 1, 5), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(1, 1, 1), Jolt.EMotionType_Static, Jolt.NON_MOVING, 0x00ff00);
				createBox(new Jolt.Vec3(0, 1, 10), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(1, 1, 1), Jolt.EMotionType_Static, Jolt.NON_MOVING, 0x00ff00);
				createBox(new Jolt.Vec3(0, 1, 15), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(1, 1, 1), Jolt.EMotionType_Static, Jolt.NON_MOVING, 0x00ff00);

				// Create ray
				let ray = new Jolt.RRayCast;
				ray.mOrigin = new Jolt.Vec3(-5, 1, -1);
				ray.mDirection = new Jolt.Vec3(10, 0, 2);
				addLine(ray.mOrigin, ray.mOrigin.Clone().Add(ray.mDirection), 0xff0000);

				// Create ray cast settings (e.g. if we want back face culling)
				let ray_settings = new Jolt.RayCastSettings;

				// Perform the ray cast as if we were a moving object
				let bp_filter = new Jolt.DefaultBroadPhaseLayerFilter(jolt.GetObjectVsBroadPhaseLayerFilter(), Jolt.MOVING);
				let object_filter = new Jolt.DefaultObjectLayerFilter(jolt.GetObjectLayerPairFilter(), Jolt.MOVING);
				let body_filter = new Jolt.BodyFilter(); // We don't want to filter out any bodies
				let shape_filter = new Jolt.ShapeFilter(); // We don't want to filter out any shapes

				// Create collector
				let collector = new Jolt.CastRayCollectorJS;
				collector.OnBody = (inBody) => {
					inBody = Jolt.wrapPointer(inBody, Jolt.Body);
					collector.body = inBody; // Store the body for the AddHit callback
				};
				collector.AddHit = (inRayCastResult) => {
					inRayCastResult = Jolt.wrapPointer(inRayCastResult, Jolt.RayCastResult);
					let hitPoint = ray.GetPointOnRay(inRayCastResult.mFraction);
					addMarker(hitPoint, 1, 0x0000ff);
					let hitNormal = collector.body.GetWorldSpaceSurfaceNormal(inRayCastResult.mSubShapeID2, hitPoint);
					addLine(hitPoint, hitPoint.Clone().Add(hitNormal.Mul(2)), 0x00ff00);
					
					// Update the collector so that it won't receive any hits further away than this hit
					collector.UpdateEarlyOutFraction(inRayCastResult.mFraction);
				};
				collector.Reset = () => {
					// Reset fraction to smallest possible value that is bigger than 1 so we can reuse this collector
					collector.ResetEarlyOutFraction(1.00000011921);
				};

				// Cast the ray against the first box
				physicsSystem.GetNarrowPhaseQuery().CastRay(ray, ray_settings, collector, bp_filter, object_filter, body_filter, shape_filter);
				
				// Recycle the collector
				collector.Reset();

				// Move the ray
				ray.mOrigin = new Jolt.Vec3(-5, 1, 4);
				addLine(ray.mOrigin, ray.mOrigin.Clone().Add(ray.mDirection), 0xff0000);

				// Cast the ray against the second box
				physicsSystem.GetNarrowPhaseQuery().CastRay(ray, ray_settings, collector, bp_filter, object_filter, body_filter, shape_filter);

				// Move the ray
				ray.mOrigin = new Jolt.Vec3(-5, 1, 9);
				addLine(ray.mOrigin, ray.mOrigin.Clone().Add(ray.mDirection), 0xff0000);

				// Cast the ray against the third box using a closest hit collector
				let closest_hit_collector = new Jolt.CastRayClosestHitCollisionCollector;
				physicsSystem.GetNarrowPhaseQuery().CastRay(ray, ray_settings, closest_hit_collector, bp_filter, object_filter, body_filter, shape_filter);
				if (closest_hit_collector.HadHit()) { 
					let hitPoint = ray.GetPointOnRay(closest_hit_collector.mHit.mFraction);
					addMarker(hitPoint, 1, 0x0000ff);
					let hitNormal = collector.body.GetWorldSpaceSurfaceNormal(closest_hit_collector.mHit.mSubShapeID2, hitPoint);
					addLine(hitPoint, hitPoint.Clone().Add(hitNormal.Mul(2)), 0x00ff00);
				}

				// Move the ray
				ray.mOrigin = new Jolt.Vec3(-5, 1, 14);
				addLine(ray.mOrigin, ray.mOrigin.Clone().Add(ray.mDirection), 0xff0000);

				// Turn off back face culling
				ray_settings.mBackFaceMode = Jolt.EBackFaceMode_CollideWithBackFaces;

				// Cast the ray against the fourth box using an all hit collector
				let all_hit_collector = new Jolt.CastRayAllHitCollisionCollector;
				physicsSystem.GetNarrowPhaseQuery().CastRay(ray, ray_settings, all_hit_collector, bp_filter, object_filter, body_filter, shape_filter);
				for (let i = 0; i < all_hit_collector.mHits.size(); i++) {
					let hit = all_hit_collector.mHits.at(i);
					let hitPoint = ray.GetPointOnRay(hit.mFraction);
					addMarker(hitPoint, 1, 0x0000ff);
					let hitNormal = collector.body.GetWorldSpaceSurfaceNormal(hit.mSubShapeID2, hitPoint);
					addLine(hitPoint, hitPoint.Clone().Add(hitNormal.Mul(2)), 0x00ff00);
				}
			});
		</script>
	</body>
</html>
